/*
Declare token types at the top of the bison file,
causing them to be automatically generated in parser.tab.h
for use by scanner.c.
*/

/*%token TOKEN_ID*/
%token TOKEN_INTEGER
%token TOKEN_FLOAT
%token TOKEN_SEMI
%token TOKEN_ADD
%token TOKEN_SUBTRACT
%token TOKEN_MULTIPLY
%token TOKEN_DIVIDE
%token TOKEN_LPAREN
%token TOKEN_RPAREN
/* new tokens */
%token TOKEN_CAR
%token TOKEN_LAT
%token TOKEN_ATOM

%{

#include <math.h>
#include <stdio.h>
#include <stdlib.h>

/*
YYSTYPE is the lexical value returned by each rule in a bison grammar.
By default, it is an integer. In this example, we are computing
arithmetic values as a double.
*/

#define YYSTYPE double

/*
Clunky: Manually declare the interface to the scanner generated by flex. 
*/

extern char *yytext;
extern int yylex();
extern int yyerror( char *str );

/*
Clunky: Keep the final result of the parse in a global variable,
so that it can be retrieved by main().
*/

double parser_result = 0.0;

%}

%%

/* Here is the grammar: program is the start symbol. */

/* new grammar for scheme*/
program	: expr
		{ parser_result = $1; return 0; }
	;
/* expression that returns a single value (ints) */
expr	: TOKEN_LPAREN func TOKEN_RPAREN
		{ $$ = $2; }
	| term
		{ $$ = $1 } 
	;
/* functions that returns a single value */
func	: TOKEN_ADD expr expr
		{ $$ = $2 + $3; }
	| TOKEN_SUBTRACT expr expr
		{ $$ = $2 - $3; }
	| TOKEN_MULTIPLY expr expr
		{ $$ = $2 * $3; }
	| TOKEN_DIVIDE expr expr
		{ $$ = $2 / $3; }
	| TOKEN_CAR list
		{ $$ = $2; } /* need to modify function to get first element of the array */
	;
/* single value (int) */
term	: TOKEN_INTEGER
		{ $$ = atoi(yytext); }
	;
/* list of values (type array of ints) */
list	: TOKEN_LPAREN list_item TOKEN_RPAREN
		{ $$ = $2; }
	;
list_item : list_item expr
		{ $$ = $2; }	/* need to modify function to set the left of the rule = to array of list_item with expr appended to the end */
	| expr		
		{ $$ = $1; }	/* need to modify function to set left of the rule = to array of length one with arr[0] = expr */
	;

/* previously existing grammer*/
/*program : expr TOKEN_SEMI
		{ parser_result = $1; return 0; }
	;

expr	: expr TOKEN_ADD term
		{ $$ = $1 + $3; }
	| expr TOKEN_SUBTRACT term
		{ $$ = $1 - $3; }
	| term
		{ $$ = $1; }
	;

term	: term TOKEN_MULTIPLY factor
		{ $$ = $1 * $3; }
	| term TOKEN_DIVIDE factor
		{
			if($3==0) {
	 			printf("runtime error: divide by zero\n");
				exit(1);
			}
			$$ = $1 / $3;
		}
	| factor
		{ $$ = $1; }
	;

factor	: TOKEN_LPAREN expr TOKEN_RPAREN
		{ $$ = $2; }
	| TOKEN_SUBTRACT factor
		{ $$ = -$2; }
	| TOKEN_FLOAT
		{ $$ = atof(yytext); }
	;
*/
%%

/*
This function will be called by bison if the parse should
encounter an error.  In principle, "str" will contain something
useful.  In practice, it often does not.
*/

int yyerror( char *str )
{
	printf("parse error: %s\n",str);
	return 0;
}
